import { gql } from 'apollo-angular';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: { input: any; output: any; }
  /** The builtin Map type */
  Map: { input: any; output: any; }
  /** The builtin Time type */
  Time: { input: any; output: any; }
  UUID: { input: any; output: any; }
};

export type BoardMeeting = Node & {
  __typename?: 'BoardMeeting';
  announcementDate: Scalars['Time']['output'];
  attachment: Scalars['String']['output'];
  createdAt: Scalars['Time']['output'];
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  meetingDate: Scalars['Time']['output'];
  purpose: Scalars['String']['output'];
  stock?: Maybe<Stock>;
  updatedAt: Scalars['Time']['output'];
};

/**
 * BoardMeetingWhereInput is used for filtering BoardMeeting objects.
 * Input was generated by ent.
 */
export type BoardMeetingWhereInput = {
  and?: InputMaybe<Array<BoardMeetingWhereInput>>;
  /** announcement_date field predicates */
  announcementDate?: InputMaybe<Scalars['Time']['input']>;
  announcementDateGT?: InputMaybe<Scalars['Time']['input']>;
  announcementDateGTE?: InputMaybe<Scalars['Time']['input']>;
  announcementDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  announcementDateLT?: InputMaybe<Scalars['Time']['input']>;
  announcementDateLTE?: InputMaybe<Scalars['Time']['input']>;
  announcementDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  announcementDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** attachment field predicates */
  attachment?: InputMaybe<Scalars['String']['input']>;
  attachmentContains?: InputMaybe<Scalars['String']['input']>;
  attachmentContainsFold?: InputMaybe<Scalars['String']['input']>;
  attachmentEqualFold?: InputMaybe<Scalars['String']['input']>;
  attachmentGT?: InputMaybe<Scalars['String']['input']>;
  attachmentGTE?: InputMaybe<Scalars['String']['input']>;
  attachmentHasPrefix?: InputMaybe<Scalars['String']['input']>;
  attachmentHasSuffix?: InputMaybe<Scalars['String']['input']>;
  attachmentIn?: InputMaybe<Array<Scalars['String']['input']>>;
  attachmentLT?: InputMaybe<Scalars['String']['input']>;
  attachmentLTE?: InputMaybe<Scalars['String']['input']>;
  attachmentNEQ?: InputMaybe<Scalars['String']['input']>;
  attachmentNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** stock edge predicates */
  hasStock?: InputMaybe<Scalars['Boolean']['input']>;
  hasStockWith?: InputMaybe<Array<StockWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** meeting_date field predicates */
  meetingDate?: InputMaybe<Scalars['Time']['input']>;
  meetingDateGT?: InputMaybe<Scalars['Time']['input']>;
  meetingDateGTE?: InputMaybe<Scalars['Time']['input']>;
  meetingDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  meetingDateLT?: InputMaybe<Scalars['Time']['input']>;
  meetingDateLTE?: InputMaybe<Scalars['Time']['input']>;
  meetingDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  meetingDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  not?: InputMaybe<BoardMeetingWhereInput>;
  or?: InputMaybe<Array<BoardMeetingWhereInput>>;
  /** purpose field predicates */
  purpose?: InputMaybe<Scalars['String']['input']>;
  purposeContains?: InputMaybe<Scalars['String']['input']>;
  purposeContainsFold?: InputMaybe<Scalars['String']['input']>;
  purposeEqualFold?: InputMaybe<Scalars['String']['input']>;
  purposeGT?: InputMaybe<Scalars['String']['input']>;
  purposeGTE?: InputMaybe<Scalars['String']['input']>;
  purposeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  purposeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  purposeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  purposeLT?: InputMaybe<Scalars['String']['input']>;
  purposeLTE?: InputMaybe<Scalars['String']['input']>;
  purposeNEQ?: InputMaybe<Scalars['String']['input']>;
  purposeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/**
 * CreateBoardMeetingInput is used for create BoardMeeting object.
 * Input was generated by ent.
 */
export type CreateBoardMeetingInput = {
  announcementDate: Scalars['Time']['input'];
  attachment?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  meetingDate: Scalars['Time']['input'];
  purpose?: InputMaybe<Scalars['String']['input']>;
  stockID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateNewsInput is used for create News object.
 * Input was generated by ent.
 */
export type CreateNewsInput = {
  content?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  imageURL: Scalars['String']['input'];
  isAnalyzed?: InputMaybe<Scalars['Boolean']['input']>;
  publishedAt?: InputMaybe<Scalars['Time']['input']>;
  source?: InputMaybe<Scalars['String']['input']>;
  stocks?: InputMaybe<Array<Scalars['String']['input']>>;
  title: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  url: Scalars['String']['input'];
};

/**
 * CreateNotificationInput is used for create Notification object.
 * Input was generated by ent.
 */
export type CreateNotificationInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  title: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreatePortfolioInput is used for create Portfolio object.
 * Input was generated by ent.
 */
export type CreatePortfolioInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  description: Scalars['String']['input'];
  invested?: InputMaybe<Scalars['Float']['input']>;
  investmentIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  name: Scalars['String']['input'];
  returns?: InputMaybe<Scalars['Float']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateRefreshTokenInput is used for create RefreshToken object.
 * Input was generated by ent.
 */
export type CreateRefreshTokenInput = {
  createdAt: Scalars['Time']['input'];
  expiresAt?: InputMaybe<Scalars['Time']['input']>;
  token: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateSentimentHistoryInput is used for create SentimentHistory object.
 * Input was generated by ent.
 */
export type CreateSentimentHistoryInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  sentiment?: InputMaybe<Scalars['Float']['input']>;
  stockID: Scalars['UUID']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateStockFundamentalHistoryInput is used for create StockFundamentalHistory object.
 * Input was generated by ent.
 */
export type CreateStockFundamentalHistoryInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  exchange: StockFundamentalHistoryExchange;
  metadata: Scalars['Map']['input'];
  stockID: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateStockFundamentalInput is used for create StockFundamental object.
 * Input was generated by ent.
 */
export type CreateStockFundamentalInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  exchange: StockFundamentalExchange;
  metadata: Scalars['Map']['input'];
  stockID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateStockInput is used for create Stock object.
 * Input was generated by ent.
 */
export type CreateStockInput = {
  boardMeetingIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  exchange?: InputMaybe<Scalars['String']['input']>;
  industry?: InputMaybe<Scalars['String']['input']>;
  investmentIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  isinCode?: InputMaybe<Scalars['String']['input']>;
  mcid: Scalars['String']['input'];
  name: Scalars['String']['input'];
  sentiment?: InputMaybe<Scalars['Float']['input']>;
  stockFundamentalIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  stockTechnicalIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  symbol: Scalars['String']['input'];
  transactionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  ttid?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateStockTechnicalInput is used for create StockTechnical object.
 * Input was generated by ent.
 */
export type CreateStockTechnicalInput = {
  closePrice?: InputMaybe<Scalars['Float']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  sma5?: InputMaybe<Scalars['Float']['input']>;
  sma10?: InputMaybe<Scalars['Float']['input']>;
  sma20?: InputMaybe<Scalars['Float']['input']>;
  sma50?: InputMaybe<Scalars['Float']['input']>;
  sma100?: InputMaybe<Scalars['Float']['input']>;
  sma200?: InputMaybe<Scalars['Float']['input']>;
  stockID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateTransactionInput is used for create Transaction object.
 * Input was generated by ent.
 */
export type CreateTransactionInput = {
  amount?: InputMaybe<Scalars['Float']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  ownerID?: InputMaybe<Scalars['ID']['input']>;
  type?: InputMaybe<TransactionType>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateUserInput is used for create User object.
 * Input was generated by ent.
 */
export type CreateUserInput = {
  balance?: InputMaybe<Scalars['Float']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  email: Scalars['String']['input'];
  investmentIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  notificationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  password: Scalars['String']['input'];
  portfolioIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  refreshTokenID?: InputMaybe<Scalars['ID']['input']>;
  transactionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  username: Scalars['String']['input'];
};

export type Investment = Node & {
  __typename?: 'Investment';
  averagePrice: Scalars['Float']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  portfolio?: Maybe<Portfolio>;
  quantity: Scalars['Float']['output'];
  stock?: Maybe<Stock>;
  updatedAt: Scalars['Time']['output'];
  user?: Maybe<User>;
};

/**
 * InvestmentWhereInput is used for filtering Investment objects.
 * Input was generated by ent.
 */
export type InvestmentWhereInput = {
  and?: InputMaybe<Array<InvestmentWhereInput>>;
  /** average_price field predicates */
  averagePrice?: InputMaybe<Scalars['Float']['input']>;
  averagePriceGT?: InputMaybe<Scalars['Float']['input']>;
  averagePriceGTE?: InputMaybe<Scalars['Float']['input']>;
  averagePriceIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  averagePriceLT?: InputMaybe<Scalars['Float']['input']>;
  averagePriceLTE?: InputMaybe<Scalars['Float']['input']>;
  averagePriceNEQ?: InputMaybe<Scalars['Float']['input']>;
  averagePriceNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** portfolio edge predicates */
  hasPortfolio?: InputMaybe<Scalars['Boolean']['input']>;
  hasPortfolioWith?: InputMaybe<Array<PortfolioWhereInput>>;
  /** stock edge predicates */
  hasStock?: InputMaybe<Scalars['Boolean']['input']>;
  hasStockWith?: InputMaybe<Array<StockWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<InvestmentWhereInput>;
  or?: InputMaybe<Array<InvestmentWhereInput>>;
  /** quantity field predicates */
  quantity?: InputMaybe<Scalars['Float']['input']>;
  quantityGT?: InputMaybe<Scalars['Float']['input']>;
  quantityGTE?: InputMaybe<Scalars['Float']['input']>;
  quantityIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  quantityLT?: InputMaybe<Scalars['Float']['input']>;
  quantityLTE?: InputMaybe<Scalars['Float']['input']>;
  quantityNEQ?: InputMaybe<Scalars['Float']['input']>;
  quantityNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type LoginPayload = {
  __typename?: 'LoginPayload';
  refreshToken: Scalars['String']['output'];
  token: Scalars['String']['output'];
  user: User;
};

export type Mutation = {
  __typename?: 'Mutation';
  addNews: News;
  register: RegisterPayload;
};


export type MutationAddNewsArgs = {
  input: NewsInput;
};


export type MutationRegisterArgs = {
  input: RegisterInput;
};

export type News = Node & {
  __typename?: 'News';
  content: Scalars['String']['output'];
  createdAt: Scalars['Time']['output'];
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  imageURL: Scalars['String']['output'];
  isAnalyzed: Scalars['Boolean']['output'];
  publishedAt: Scalars['Time']['output'];
  source: Scalars['String']['output'];
  stocks: Array<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
  url: Scalars['String']['output'];
};

export type NewsInput = {
  content: Scalars['String']['input'];
  description: Scalars['String']['input'];
  publishedAt: Scalars['String']['input'];
  stock: Array<Scalars['String']['input']>;
  title: Scalars['String']['input'];
  url: Scalars['String']['input'];
  urlToImage: Scalars['String']['input'];
};

/**
 * NewsWhereInput is used for filtering News objects.
 * Input was generated by ent.
 */
export type NewsWhereInput = {
  and?: InputMaybe<Array<NewsWhereInput>>;
  /** content field predicates */
  content?: InputMaybe<Scalars['String']['input']>;
  contentContains?: InputMaybe<Scalars['String']['input']>;
  contentContainsFold?: InputMaybe<Scalars['String']['input']>;
  contentEqualFold?: InputMaybe<Scalars['String']['input']>;
  contentGT?: InputMaybe<Scalars['String']['input']>;
  contentGTE?: InputMaybe<Scalars['String']['input']>;
  contentHasPrefix?: InputMaybe<Scalars['String']['input']>;
  contentHasSuffix?: InputMaybe<Scalars['String']['input']>;
  contentIn?: InputMaybe<Array<Scalars['String']['input']>>;
  contentLT?: InputMaybe<Scalars['String']['input']>;
  contentLTE?: InputMaybe<Scalars['String']['input']>;
  contentNEQ?: InputMaybe<Scalars['String']['input']>;
  contentNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** image_url field predicates */
  imageURL?: InputMaybe<Scalars['String']['input']>;
  imageURLContains?: InputMaybe<Scalars['String']['input']>;
  imageURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  imageURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  imageURLGT?: InputMaybe<Scalars['String']['input']>;
  imageURLGTE?: InputMaybe<Scalars['String']['input']>;
  imageURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  imageURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  imageURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  imageURLLT?: InputMaybe<Scalars['String']['input']>;
  imageURLLTE?: InputMaybe<Scalars['String']['input']>;
  imageURLNEQ?: InputMaybe<Scalars['String']['input']>;
  imageURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** is_analyzed field predicates */
  isAnalyzed?: InputMaybe<Scalars['Boolean']['input']>;
  isAnalyzedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<NewsWhereInput>;
  or?: InputMaybe<Array<NewsWhereInput>>;
  /** published_at field predicates */
  publishedAt?: InputMaybe<Scalars['Time']['input']>;
  publishedAtGT?: InputMaybe<Scalars['Time']['input']>;
  publishedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  publishedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  publishedAtLT?: InputMaybe<Scalars['Time']['input']>;
  publishedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  publishedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  publishedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** source field predicates */
  source?: InputMaybe<Scalars['String']['input']>;
  sourceContains?: InputMaybe<Scalars['String']['input']>;
  sourceContainsFold?: InputMaybe<Scalars['String']['input']>;
  sourceEqualFold?: InputMaybe<Scalars['String']['input']>;
  sourceGT?: InputMaybe<Scalars['String']['input']>;
  sourceGTE?: InputMaybe<Scalars['String']['input']>;
  sourceHasPrefix?: InputMaybe<Scalars['String']['input']>;
  sourceHasSuffix?: InputMaybe<Scalars['String']['input']>;
  sourceIn?: InputMaybe<Array<Scalars['String']['input']>>;
  sourceLT?: InputMaybe<Scalars['String']['input']>;
  sourceLTE?: InputMaybe<Scalars['String']['input']>;
  sourceNEQ?: InputMaybe<Scalars['String']['input']>;
  sourceNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** url field predicates */
  url?: InputMaybe<Scalars['String']['input']>;
  urlContains?: InputMaybe<Scalars['String']['input']>;
  urlContainsFold?: InputMaybe<Scalars['String']['input']>;
  urlEqualFold?: InputMaybe<Scalars['String']['input']>;
  urlGT?: InputMaybe<Scalars['String']['input']>;
  urlGTE?: InputMaybe<Scalars['String']['input']>;
  urlHasPrefix?: InputMaybe<Scalars['String']['input']>;
  urlHasSuffix?: InputMaybe<Scalars['String']['input']>;
  urlIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlLT?: InputMaybe<Scalars['String']['input']>;
  urlLTE?: InputMaybe<Scalars['String']['input']>;
  urlNEQ?: InputMaybe<Scalars['String']['input']>;
  urlNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output'];
};

export type Notification = Node & {
  __typename?: 'Notification';
  createdAt: Scalars['Time']['output'];
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  isRead: Scalars['Boolean']['output'];
  title: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
  user?: Maybe<User>;
};

/**
 * NotificationWhereInput is used for filtering Notification objects.
 * Input was generated by ent.
 */
export type NotificationWhereInput = {
  and?: InputMaybe<Array<NotificationWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_read field predicates */
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  isReadNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<NotificationWhereInput>;
  or?: InputMaybe<Array<NotificationWhereInput>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type Portfolio = Node & {
  __typename?: 'Portfolio';
  createdAt: Scalars['Time']['output'];
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  invested: Scalars['Float']['output'];
  investments?: Maybe<Array<Investment>>;
  name: Scalars['String']['output'];
  returns: Scalars['Float']['output'];
  updatedAt: Scalars['Time']['output'];
  user?: Maybe<User>;
};

export type PortfolioResponse = {
  __typename?: 'PortfolioResponse';
  investment: Scalars['Float']['output'];
  portfolio: Portfolio;
  return: Scalars['Float']['output'];
  returnPercentage: Scalars['Float']['output'];
};

/**
 * PortfolioWhereInput is used for filtering Portfolio objects.
 * Input was generated by ent.
 */
export type PortfolioWhereInput = {
  and?: InputMaybe<Array<PortfolioWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** investments edge predicates */
  hasInvestments?: InputMaybe<Scalars['Boolean']['input']>;
  hasInvestmentsWith?: InputMaybe<Array<InvestmentWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** invested field predicates */
  invested?: InputMaybe<Scalars['Float']['input']>;
  investedGT?: InputMaybe<Scalars['Float']['input']>;
  investedGTE?: InputMaybe<Scalars['Float']['input']>;
  investedIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  investedLT?: InputMaybe<Scalars['Float']['input']>;
  investedLTE?: InputMaybe<Scalars['Float']['input']>;
  investedNEQ?: InputMaybe<Scalars['Float']['input']>;
  investedNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<PortfolioWhereInput>;
  or?: InputMaybe<Array<PortfolioWhereInput>>;
  /** returns field predicates */
  returns?: InputMaybe<Scalars['Float']['input']>;
  returnsGT?: InputMaybe<Scalars['Float']['input']>;
  returnsGTE?: InputMaybe<Scalars['Float']['input']>;
  returnsIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  returnsLT?: InputMaybe<Scalars['Float']['input']>;
  returnsLTE?: InputMaybe<Scalars['Float']['input']>;
  returnsNEQ?: InputMaybe<Scalars['Float']['input']>;
  returnsNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type Query = {
  __typename?: 'Query';
  login: LoginPayload;
  me: User;
  news: Array<News>;
  newsById: News;
  newsSlice: Array<News>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  notifications: Array<Notification>;
  portfolios: Array<Portfolio>;
  portfoliosByUser: Array<PortfolioResponse>;
  priceByStockId: Scalars['Float']['output'];
  refreshTokens: Array<RefreshToken>;
  stock: Array<Maybe<Stock>>;
  stocks: Array<Stock>;
  stocksBySentiment: Array<Stock>;
  topLosersGainers: TopLosersGainers;
  transactions: Array<Transaction>;
  users: Array<User>;
};


export type QueryLoginArgs = {
  password: Scalars['String']['input'];
  username: Scalars['String']['input'];
};


export type QueryNewsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderOn?: InputMaybe<Scalars['String']['input']>;
  orderType?: InputMaybe<Scalars['String']['input']>;
};


export type QueryNewsByIdArgs = {
  id: Scalars['String']['input'];
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type QueryPortfoliosByUserArgs = {
  userId: Scalars['String']['input'];
};


export type QueryPriceByStockIdArgs = {
  stockId: Scalars['String']['input'];
};


export type QueryStockArgs = {
  symbol: Scalars['String']['input'];
};


export type QueryStocksBySentimentArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderType?: InputMaybe<Scalars['String']['input']>;
};


export type QueryTopLosersGainersArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};

export type RefreshToken = Node & {
  __typename?: 'RefreshToken';
  createdAt: Scalars['Time']['output'];
  expiresAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  token: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
  user?: Maybe<User>;
};

/**
 * RefreshTokenWhereInput is used for filtering RefreshToken objects.
 * Input was generated by ent.
 */
export type RefreshTokenWhereInput = {
  and?: InputMaybe<Array<RefreshTokenWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** expires_at field predicates */
  expiresAt?: InputMaybe<Scalars['Time']['input']>;
  expiresAtGT?: InputMaybe<Scalars['Time']['input']>;
  expiresAtGTE?: InputMaybe<Scalars['Time']['input']>;
  expiresAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  expiresAtLT?: InputMaybe<Scalars['Time']['input']>;
  expiresAtLTE?: InputMaybe<Scalars['Time']['input']>;
  expiresAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  expiresAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<RefreshTokenWhereInput>;
  or?: InputMaybe<Array<RefreshTokenWhereInput>>;
  /** token field predicates */
  token?: InputMaybe<Scalars['String']['input']>;
  tokenContains?: InputMaybe<Scalars['String']['input']>;
  tokenContainsFold?: InputMaybe<Scalars['String']['input']>;
  tokenEqualFold?: InputMaybe<Scalars['String']['input']>;
  tokenGT?: InputMaybe<Scalars['String']['input']>;
  tokenGTE?: InputMaybe<Scalars['String']['input']>;
  tokenHasPrefix?: InputMaybe<Scalars['String']['input']>;
  tokenHasSuffix?: InputMaybe<Scalars['String']['input']>;
  tokenIn?: InputMaybe<Array<Scalars['String']['input']>>;
  tokenLT?: InputMaybe<Scalars['String']['input']>;
  tokenLTE?: InputMaybe<Scalars['String']['input']>;
  tokenNEQ?: InputMaybe<Scalars['String']['input']>;
  tokenNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type RegisterInput = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
  username: Scalars['String']['input'];
};

export type RegisterPayload = {
  __typename?: 'RegisterPayload';
  refreshToken: Scalars['String']['output'];
  token: Scalars['String']['output'];
  user: User;
};

export type SentimentHistory = Node & {
  __typename?: 'SentimentHistory';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  sentiment: Scalars['Float']['output'];
  stockID: Scalars['UUID']['output'];
  updatedAt: Scalars['Time']['output'];
};

/**
 * SentimentHistoryWhereInput is used for filtering SentimentHistory objects.
 * Input was generated by ent.
 */
export type SentimentHistoryWhereInput = {
  and?: InputMaybe<Array<SentimentHistoryWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<SentimentHistoryWhereInput>;
  or?: InputMaybe<Array<SentimentHistoryWhereInput>>;
  /** sentiment field predicates */
  sentiment?: InputMaybe<Scalars['Float']['input']>;
  sentimentGT?: InputMaybe<Scalars['Float']['input']>;
  sentimentGTE?: InputMaybe<Scalars['Float']['input']>;
  sentimentIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  sentimentLT?: InputMaybe<Scalars['Float']['input']>;
  sentimentLTE?: InputMaybe<Scalars['Float']['input']>;
  sentimentNEQ?: InputMaybe<Scalars['Float']['input']>;
  sentimentNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** stock_id field predicates */
  stockID?: InputMaybe<Scalars['UUID']['input']>;
  stockIDGT?: InputMaybe<Scalars['UUID']['input']>;
  stockIDGTE?: InputMaybe<Scalars['UUID']['input']>;
  stockIDIn?: InputMaybe<Array<Scalars['UUID']['input']>>;
  stockIDLT?: InputMaybe<Scalars['UUID']['input']>;
  stockIDLTE?: InputMaybe<Scalars['UUID']['input']>;
  stockIDNEQ?: InputMaybe<Scalars['UUID']['input']>;
  stockIDNotIn?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type Stock = Node & {
  __typename?: 'Stock';
  boardMeetings?: Maybe<Array<BoardMeeting>>;
  createdAt: Scalars['Time']['output'];
  description: Scalars['String']['output'];
  exchange: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  industry: Scalars['String']['output'];
  investments?: Maybe<Array<Investment>>;
  isinCode?: Maybe<Scalars['String']['output']>;
  mcid: Scalars['String']['output'];
  name: Scalars['String']['output'];
  sentiment: Scalars['Float']['output'];
  stockFundamental?: Maybe<Array<StockFundamental>>;
  stockTechnicals?: Maybe<Array<StockTechnical>>;
  symbol: Scalars['String']['output'];
  transactions?: Maybe<Array<Transaction>>;
  ttid: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
};

export type StockFundamental = Node & {
  __typename?: 'StockFundamental';
  createdAt: Scalars['Time']['output'];
  exchange: StockFundamentalExchange;
  id: Scalars['ID']['output'];
  metadata: Scalars['Map']['output'];
  stock?: Maybe<Stock>;
  updatedAt: Scalars['Time']['output'];
};

/** StockFundamentalExchange is enum for the field exchange */
export enum StockFundamentalExchange {
  Bse = 'BSE',
  Nse = 'NSE'
}

export type StockFundamentalHistory = Node & {
  __typename?: 'StockFundamentalHistory';
  createdAt: Scalars['Time']['output'];
  exchange: StockFundamentalHistoryExchange;
  id: Scalars['ID']['output'];
  metadata: Scalars['Map']['output'];
  stockID: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
};

/** StockFundamentalHistoryExchange is enum for the field exchange */
export enum StockFundamentalHistoryExchange {
  Bse = 'BSE',
  Nse = 'NSE'
}

/**
 * StockFundamentalHistoryWhereInput is used for filtering StockFundamentalHistory objects.
 * Input was generated by ent.
 */
export type StockFundamentalHistoryWhereInput = {
  and?: InputMaybe<Array<StockFundamentalHistoryWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** exchange field predicates */
  exchange?: InputMaybe<StockFundamentalHistoryExchange>;
  exchangeIn?: InputMaybe<Array<StockFundamentalHistoryExchange>>;
  exchangeNEQ?: InputMaybe<StockFundamentalHistoryExchange>;
  exchangeNotIn?: InputMaybe<Array<StockFundamentalHistoryExchange>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<StockFundamentalHistoryWhereInput>;
  or?: InputMaybe<Array<StockFundamentalHistoryWhereInput>>;
  /** stock_id field predicates */
  stockID?: InputMaybe<Scalars['String']['input']>;
  stockIDContains?: InputMaybe<Scalars['String']['input']>;
  stockIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  stockIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  stockIDGT?: InputMaybe<Scalars['String']['input']>;
  stockIDGTE?: InputMaybe<Scalars['String']['input']>;
  stockIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  stockIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  stockIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  stockIDLT?: InputMaybe<Scalars['String']['input']>;
  stockIDLTE?: InputMaybe<Scalars['String']['input']>;
  stockIDNEQ?: InputMaybe<Scalars['String']['input']>;
  stockIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/**
 * StockFundamentalWhereInput is used for filtering StockFundamental objects.
 * Input was generated by ent.
 */
export type StockFundamentalWhereInput = {
  and?: InputMaybe<Array<StockFundamentalWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** exchange field predicates */
  exchange?: InputMaybe<StockFundamentalExchange>;
  exchangeIn?: InputMaybe<Array<StockFundamentalExchange>>;
  exchangeNEQ?: InputMaybe<StockFundamentalExchange>;
  exchangeNotIn?: InputMaybe<Array<StockFundamentalExchange>>;
  /** stock edge predicates */
  hasStock?: InputMaybe<Scalars['Boolean']['input']>;
  hasStockWith?: InputMaybe<Array<StockWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<StockFundamentalWhereInput>;
  or?: InputMaybe<Array<StockFundamentalWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type StockMarketData = {
  __typename?: 'StockMarketData';
  Change: Scalars['Float']['output'];
  Close: Scalars['Float']['output'];
  CompanyName: Scalars['String']['output'];
  PercentChange: Scalars['Float']['output'];
  Symbol: Scalars['String']['output'];
};

export type StockTechnical = Node & {
  __typename?: 'StockTechnical';
  closePrice: Scalars['Float']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  sma5: Scalars['Float']['output'];
  sma10: Scalars['Float']['output'];
  sma20: Scalars['Float']['output'];
  sma50: Scalars['Float']['output'];
  sma100: Scalars['Float']['output'];
  sma200: Scalars['Float']['output'];
  stock?: Maybe<Stock>;
  updatedAt: Scalars['Time']['output'];
};

/**
 * StockTechnicalWhereInput is used for filtering StockTechnical objects.
 * Input was generated by ent.
 */
export type StockTechnicalWhereInput = {
  and?: InputMaybe<Array<StockTechnicalWhereInput>>;
  /** close_price field predicates */
  closePrice?: InputMaybe<Scalars['Float']['input']>;
  closePriceGT?: InputMaybe<Scalars['Float']['input']>;
  closePriceGTE?: InputMaybe<Scalars['Float']['input']>;
  closePriceIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  closePriceLT?: InputMaybe<Scalars['Float']['input']>;
  closePriceLTE?: InputMaybe<Scalars['Float']['input']>;
  closePriceNEQ?: InputMaybe<Scalars['Float']['input']>;
  closePriceNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** stock edge predicates */
  hasStock?: InputMaybe<Scalars['Boolean']['input']>;
  hasStockWith?: InputMaybe<Array<StockWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<StockTechnicalWhereInput>;
  or?: InputMaybe<Array<StockTechnicalWhereInput>>;
  /** sma5 field predicates */
  sma5?: InputMaybe<Scalars['Float']['input']>;
  sma5GT?: InputMaybe<Scalars['Float']['input']>;
  sma5GTE?: InputMaybe<Scalars['Float']['input']>;
  sma5In?: InputMaybe<Array<Scalars['Float']['input']>>;
  sma5LT?: InputMaybe<Scalars['Float']['input']>;
  sma5LTE?: InputMaybe<Scalars['Float']['input']>;
  sma5NEQ?: InputMaybe<Scalars['Float']['input']>;
  sma5NotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** sma10 field predicates */
  sma10?: InputMaybe<Scalars['Float']['input']>;
  sma10GT?: InputMaybe<Scalars['Float']['input']>;
  sma10GTE?: InputMaybe<Scalars['Float']['input']>;
  sma10In?: InputMaybe<Array<Scalars['Float']['input']>>;
  sma10LT?: InputMaybe<Scalars['Float']['input']>;
  sma10LTE?: InputMaybe<Scalars['Float']['input']>;
  sma10NEQ?: InputMaybe<Scalars['Float']['input']>;
  sma10NotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** sma20 field predicates */
  sma20?: InputMaybe<Scalars['Float']['input']>;
  sma20GT?: InputMaybe<Scalars['Float']['input']>;
  sma20GTE?: InputMaybe<Scalars['Float']['input']>;
  sma20In?: InputMaybe<Array<Scalars['Float']['input']>>;
  sma20LT?: InputMaybe<Scalars['Float']['input']>;
  sma20LTE?: InputMaybe<Scalars['Float']['input']>;
  sma20NEQ?: InputMaybe<Scalars['Float']['input']>;
  sma20NotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** sma50 field predicates */
  sma50?: InputMaybe<Scalars['Float']['input']>;
  sma50GT?: InputMaybe<Scalars['Float']['input']>;
  sma50GTE?: InputMaybe<Scalars['Float']['input']>;
  sma50In?: InputMaybe<Array<Scalars['Float']['input']>>;
  sma50LT?: InputMaybe<Scalars['Float']['input']>;
  sma50LTE?: InputMaybe<Scalars['Float']['input']>;
  sma50NEQ?: InputMaybe<Scalars['Float']['input']>;
  sma50NotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** sma100 field predicates */
  sma100?: InputMaybe<Scalars['Float']['input']>;
  sma100GT?: InputMaybe<Scalars['Float']['input']>;
  sma100GTE?: InputMaybe<Scalars['Float']['input']>;
  sma100In?: InputMaybe<Array<Scalars['Float']['input']>>;
  sma100LT?: InputMaybe<Scalars['Float']['input']>;
  sma100LTE?: InputMaybe<Scalars['Float']['input']>;
  sma100NEQ?: InputMaybe<Scalars['Float']['input']>;
  sma100NotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** sma200 field predicates */
  sma200?: InputMaybe<Scalars['Float']['input']>;
  sma200GT?: InputMaybe<Scalars['Float']['input']>;
  sma200GTE?: InputMaybe<Scalars['Float']['input']>;
  sma200In?: InputMaybe<Array<Scalars['Float']['input']>>;
  sma200LT?: InputMaybe<Scalars['Float']['input']>;
  sma200LTE?: InputMaybe<Scalars['Float']['input']>;
  sma200NEQ?: InputMaybe<Scalars['Float']['input']>;
  sma200NotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/**
 * StockWhereInput is used for filtering Stock objects.
 * Input was generated by ent.
 */
export type StockWhereInput = {
  and?: InputMaybe<Array<StockWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** exchange field predicates */
  exchange?: InputMaybe<Scalars['String']['input']>;
  exchangeContains?: InputMaybe<Scalars['String']['input']>;
  exchangeContainsFold?: InputMaybe<Scalars['String']['input']>;
  exchangeEqualFold?: InputMaybe<Scalars['String']['input']>;
  exchangeGT?: InputMaybe<Scalars['String']['input']>;
  exchangeGTE?: InputMaybe<Scalars['String']['input']>;
  exchangeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  exchangeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  exchangeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  exchangeLT?: InputMaybe<Scalars['String']['input']>;
  exchangeLTE?: InputMaybe<Scalars['String']['input']>;
  exchangeNEQ?: InputMaybe<Scalars['String']['input']>;
  exchangeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** board_meetings edge predicates */
  hasBoardMeetings?: InputMaybe<Scalars['Boolean']['input']>;
  hasBoardMeetingsWith?: InputMaybe<Array<BoardMeetingWhereInput>>;
  /** investments edge predicates */
  hasInvestments?: InputMaybe<Scalars['Boolean']['input']>;
  hasInvestmentsWith?: InputMaybe<Array<InvestmentWhereInput>>;
  /** stock_fundamental edge predicates */
  hasStockFundamental?: InputMaybe<Scalars['Boolean']['input']>;
  hasStockFundamentalWith?: InputMaybe<Array<StockFundamentalWhereInput>>;
  /** stock_technicals edge predicates */
  hasStockTechnicals?: InputMaybe<Scalars['Boolean']['input']>;
  hasStockTechnicalsWith?: InputMaybe<Array<StockTechnicalWhereInput>>;
  /** transactions edge predicates */
  hasTransactions?: InputMaybe<Scalars['Boolean']['input']>;
  hasTransactionsWith?: InputMaybe<Array<TransactionWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** industry field predicates */
  industry?: InputMaybe<Scalars['String']['input']>;
  industryContains?: InputMaybe<Scalars['String']['input']>;
  industryContainsFold?: InputMaybe<Scalars['String']['input']>;
  industryEqualFold?: InputMaybe<Scalars['String']['input']>;
  industryGT?: InputMaybe<Scalars['String']['input']>;
  industryGTE?: InputMaybe<Scalars['String']['input']>;
  industryHasPrefix?: InputMaybe<Scalars['String']['input']>;
  industryHasSuffix?: InputMaybe<Scalars['String']['input']>;
  industryIn?: InputMaybe<Array<Scalars['String']['input']>>;
  industryLT?: InputMaybe<Scalars['String']['input']>;
  industryLTE?: InputMaybe<Scalars['String']['input']>;
  industryNEQ?: InputMaybe<Scalars['String']['input']>;
  industryNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** isin_code field predicates */
  isinCode?: InputMaybe<Scalars['String']['input']>;
  isinCodeContains?: InputMaybe<Scalars['String']['input']>;
  isinCodeContainsFold?: InputMaybe<Scalars['String']['input']>;
  isinCodeEqualFold?: InputMaybe<Scalars['String']['input']>;
  isinCodeGT?: InputMaybe<Scalars['String']['input']>;
  isinCodeGTE?: InputMaybe<Scalars['String']['input']>;
  isinCodeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  isinCodeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  isinCodeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  isinCodeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  isinCodeLT?: InputMaybe<Scalars['String']['input']>;
  isinCodeLTE?: InputMaybe<Scalars['String']['input']>;
  isinCodeNEQ?: InputMaybe<Scalars['String']['input']>;
  isinCodeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  isinCodeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** mcid field predicates */
  mcid?: InputMaybe<Scalars['String']['input']>;
  mcidContains?: InputMaybe<Scalars['String']['input']>;
  mcidContainsFold?: InputMaybe<Scalars['String']['input']>;
  mcidEqualFold?: InputMaybe<Scalars['String']['input']>;
  mcidGT?: InputMaybe<Scalars['String']['input']>;
  mcidGTE?: InputMaybe<Scalars['String']['input']>;
  mcidHasPrefix?: InputMaybe<Scalars['String']['input']>;
  mcidHasSuffix?: InputMaybe<Scalars['String']['input']>;
  mcidIn?: InputMaybe<Array<Scalars['String']['input']>>;
  mcidLT?: InputMaybe<Scalars['String']['input']>;
  mcidLTE?: InputMaybe<Scalars['String']['input']>;
  mcidNEQ?: InputMaybe<Scalars['String']['input']>;
  mcidNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<StockWhereInput>;
  or?: InputMaybe<Array<StockWhereInput>>;
  /** sentiment field predicates */
  sentiment?: InputMaybe<Scalars['Float']['input']>;
  sentimentGT?: InputMaybe<Scalars['Float']['input']>;
  sentimentGTE?: InputMaybe<Scalars['Float']['input']>;
  sentimentIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  sentimentLT?: InputMaybe<Scalars['Float']['input']>;
  sentimentLTE?: InputMaybe<Scalars['Float']['input']>;
  sentimentNEQ?: InputMaybe<Scalars['Float']['input']>;
  sentimentNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** symbol field predicates */
  symbol?: InputMaybe<Scalars['String']['input']>;
  symbolContains?: InputMaybe<Scalars['String']['input']>;
  symbolContainsFold?: InputMaybe<Scalars['String']['input']>;
  symbolEqualFold?: InputMaybe<Scalars['String']['input']>;
  symbolGT?: InputMaybe<Scalars['String']['input']>;
  symbolGTE?: InputMaybe<Scalars['String']['input']>;
  symbolHasPrefix?: InputMaybe<Scalars['String']['input']>;
  symbolHasSuffix?: InputMaybe<Scalars['String']['input']>;
  symbolIn?: InputMaybe<Array<Scalars['String']['input']>>;
  symbolLT?: InputMaybe<Scalars['String']['input']>;
  symbolLTE?: InputMaybe<Scalars['String']['input']>;
  symbolNEQ?: InputMaybe<Scalars['String']['input']>;
  symbolNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** ttid field predicates */
  ttid?: InputMaybe<Scalars['String']['input']>;
  ttidContains?: InputMaybe<Scalars['String']['input']>;
  ttidContainsFold?: InputMaybe<Scalars['String']['input']>;
  ttidEqualFold?: InputMaybe<Scalars['String']['input']>;
  ttidGT?: InputMaybe<Scalars['String']['input']>;
  ttidGTE?: InputMaybe<Scalars['String']['input']>;
  ttidHasPrefix?: InputMaybe<Scalars['String']['input']>;
  ttidHasSuffix?: InputMaybe<Scalars['String']['input']>;
  ttidIn?: InputMaybe<Array<Scalars['String']['input']>>;
  ttidLT?: InputMaybe<Scalars['String']['input']>;
  ttidLTE?: InputMaybe<Scalars['String']['input']>;
  ttidNEQ?: InputMaybe<Scalars['String']['input']>;
  ttidNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type TopLosersGainers = {
  __typename?: 'TopLosersGainers';
  GainersBse: Array<StockMarketData>;
  GainersNse: Array<StockMarketData>;
  LosersBse: Array<StockMarketData>;
  LosersNse: Array<StockMarketData>;
};

export type Transaction = Node & {
  __typename?: 'Transaction';
  amount: Scalars['Float']['output'];
  createdAt: Scalars['Time']['output'];
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  owner?: Maybe<User>;
  type: TransactionType;
  updatedAt: Scalars['Time']['output'];
};

/** TransactionType is enum for the field type */
export enum TransactionType {
  Credit = 'credit',
  Debit = 'debit'
}

/**
 * TransactionWhereInput is used for filtering Transaction objects.
 * Input was generated by ent.
 */
export type TransactionWhereInput = {
  /** amount field predicates */
  amount?: InputMaybe<Scalars['Float']['input']>;
  amountGT?: InputMaybe<Scalars['Float']['input']>;
  amountGTE?: InputMaybe<Scalars['Float']['input']>;
  amountIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  amountLT?: InputMaybe<Scalars['Float']['input']>;
  amountLTE?: InputMaybe<Scalars['Float']['input']>;
  amountNEQ?: InputMaybe<Scalars['Float']['input']>;
  amountNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  and?: InputMaybe<Array<TransactionWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** owner edge predicates */
  hasOwner?: InputMaybe<Scalars['Boolean']['input']>;
  hasOwnerWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<TransactionWhereInput>;
  or?: InputMaybe<Array<TransactionWhereInput>>;
  /** type field predicates */
  type?: InputMaybe<TransactionType>;
  typeIn?: InputMaybe<Array<TransactionType>>;
  typeNEQ?: InputMaybe<TransactionType>;
  typeNotIn?: InputMaybe<Array<TransactionType>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/**
 * UpdateBoardMeetingInput is used for update BoardMeeting object.
 * Input was generated by ent.
 */
export type UpdateBoardMeetingInput = {
  announcementDate?: InputMaybe<Scalars['Time']['input']>;
  attachment?: InputMaybe<Scalars['String']['input']>;
  clearStock?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  meetingDate?: InputMaybe<Scalars['Time']['input']>;
  purpose?: InputMaybe<Scalars['String']['input']>;
  stockID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateSentimentHistoryInput is used for update SentimentHistory object.
 * Input was generated by ent.
 */
export type UpdateSentimentHistoryInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  sentiment?: InputMaybe<Scalars['Float']['input']>;
  stockID?: InputMaybe<Scalars['UUID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateStockFundamentalHistoryInput is used for update StockFundamentalHistory object.
 * Input was generated by ent.
 */
export type UpdateStockFundamentalHistoryInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  exchange?: InputMaybe<StockFundamentalHistoryExchange>;
  metadata?: InputMaybe<Scalars['Map']['input']>;
  stockID?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateStockFundamentalInput is used for update StockFundamental object.
 * Input was generated by ent.
 */
export type UpdateStockFundamentalInput = {
  clearStock?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  exchange?: InputMaybe<StockFundamentalExchange>;
  metadata?: InputMaybe<Scalars['Map']['input']>;
  stockID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateStockTechnicalInput is used for update StockTechnical object.
 * Input was generated by ent.
 */
export type UpdateStockTechnicalInput = {
  clearStock?: InputMaybe<Scalars['Boolean']['input']>;
  closePrice?: InputMaybe<Scalars['Float']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  sma5?: InputMaybe<Scalars['Float']['input']>;
  sma10?: InputMaybe<Scalars['Float']['input']>;
  sma20?: InputMaybe<Scalars['Float']['input']>;
  sma50?: InputMaybe<Scalars['Float']['input']>;
  sma100?: InputMaybe<Scalars['Float']['input']>;
  sma200?: InputMaybe<Scalars['Float']['input']>;
  stockID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

export type User = Node & {
  __typename?: 'User';
  balance: Scalars['Float']['output'];
  createdAt: Scalars['Time']['output'];
  email: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  investments?: Maybe<Array<Investment>>;
  isAdmin: Scalars['Boolean']['output'];
  notifications?: Maybe<Array<Notification>>;
  portfolios?: Maybe<Array<Portfolio>>;
  refreshToken?: Maybe<RefreshToken>;
  transactions?: Maybe<Array<Transaction>>;
  updatedAt: Scalars['Time']['output'];
  username: Scalars['String']['output'];
};

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** balance field predicates */
  balance?: InputMaybe<Scalars['Float']['input']>;
  balanceGT?: InputMaybe<Scalars['Float']['input']>;
  balanceGTE?: InputMaybe<Scalars['Float']['input']>;
  balanceIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  balanceLT?: InputMaybe<Scalars['Float']['input']>;
  balanceLTE?: InputMaybe<Scalars['Float']['input']>;
  balanceNEQ?: InputMaybe<Scalars['Float']['input']>;
  balanceNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']['input']>;
  emailContains?: InputMaybe<Scalars['String']['input']>;
  emailContainsFold?: InputMaybe<Scalars['String']['input']>;
  emailEqualFold?: InputMaybe<Scalars['String']['input']>;
  emailGT?: InputMaybe<Scalars['String']['input']>;
  emailGTE?: InputMaybe<Scalars['String']['input']>;
  emailHasPrefix?: InputMaybe<Scalars['String']['input']>;
  emailHasSuffix?: InputMaybe<Scalars['String']['input']>;
  emailIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emailLT?: InputMaybe<Scalars['String']['input']>;
  emailLTE?: InputMaybe<Scalars['String']['input']>;
  emailNEQ?: InputMaybe<Scalars['String']['input']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** investments edge predicates */
  hasInvestments?: InputMaybe<Scalars['Boolean']['input']>;
  hasInvestmentsWith?: InputMaybe<Array<InvestmentWhereInput>>;
  /** notifications edge predicates */
  hasNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  hasNotificationsWith?: InputMaybe<Array<NotificationWhereInput>>;
  /** portfolios edge predicates */
  hasPortfolios?: InputMaybe<Scalars['Boolean']['input']>;
  hasPortfoliosWith?: InputMaybe<Array<PortfolioWhereInput>>;
  /** refresh_token edge predicates */
  hasRefreshToken?: InputMaybe<Scalars['Boolean']['input']>;
  hasRefreshTokenWith?: InputMaybe<Array<RefreshTokenWhereInput>>;
  /** transactions edge predicates */
  hasTransactions?: InputMaybe<Scalars['Boolean']['input']>;
  hasTransactionsWith?: InputMaybe<Array<TransactionWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_admin field predicates */
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  isAdminNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** username field predicates */
  username?: InputMaybe<Scalars['String']['input']>;
  usernameContains?: InputMaybe<Scalars['String']['input']>;
  usernameContainsFold?: InputMaybe<Scalars['String']['input']>;
  usernameEqualFold?: InputMaybe<Scalars['String']['input']>;
  usernameGT?: InputMaybe<Scalars['String']['input']>;
  usernameGTE?: InputMaybe<Scalars['String']['input']>;
  usernameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  usernameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  usernameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  usernameLT?: InputMaybe<Scalars['String']['input']>;
  usernameLTE?: InputMaybe<Scalars['String']['input']>;
  usernameNEQ?: InputMaybe<Scalars['String']['input']>;
  usernameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};
